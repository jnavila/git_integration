#!/bin/bash

usage(){
	echo "Usage: $0"
	exit 1
}

build_cmd=$(git config integration.cmd)
if [ -z "$build_cmd" ]; then
    echo "please define config integration.cmd"
    exit 1;
fi

sequence_origin=$(git config integration.origin)
if [ -z "$sequence_origin" ]; then
    echo "please define config integration.origin"
    exit 1;
fi
    
workinghead=$(git symbolic-ref HEAD 2> /dev/null | cut -b 12-)

PRIVATE_BUILD=$(git rev-parse --show-toplevel)/.privatebuild

if [ ! -d "$PRIVATE_BUILD" ]; then
  git clone . "$PRIVATE_BUILD" >/dev/null
fi

cd "$PRIVATE_BUILD"
git clean -df
git fetch origin >/dev/null 2>/dev/null

already_passed() {
    obdata=$t-$1
    obhash=`echo $obdata | git hash-object --stdin`
    git cat-file blob $obhash > /dev/null 2>/dev/null \
        && echo "Already ${ref_name} $1"
}

passed_on() {
    obdata=$t-$1
    echo $obdata | git hash-object -w --stdin > /dev/null
    echo "Passed: $1."
}

broke_on() {
    echo "Broke on $1"
    status=1
    return 1
}

new_test() {
    (git reset --hard $v > /dev/null 2>/dev/null) && git clean -df && eval "$2" && passed_on $1 || broke_on $v
    return $?
}

echo "Testing $build_cmd on ${sequence_origin}..${workinghead}"
t=`echo "$build_cmd" | git hash-object --stdin`
status=0
for v in $(git rev-list --reverse origin/${sequence_origin}..origin/${workinghead})
do
    tree_ver=`git rev-parse "$v^{tree}"`
    already_passed $tree_ver || new_test $tree_ver "$build_cmd" || break
done

if [ $status -eq 0 ]; then
    tput setaf 2
    echo "Integration OK"
    tput sgr0
else
    tput bold; tput setaf 1
    echo "Integration Failed!"
    tput sgr0
    exit $?
fi

cd - >/dev/null